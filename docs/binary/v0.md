# The Neutron Format (v0)

The Neutron Format is the binary representation of a Pulsar Module.

## Grammar

Each structure is described with the following syntax:

```rs
[S] : T    - N
...
[S] : T[L] - N
```

Where *T* is a type described in this spec, *S* its size in bytes
and *N* a descriptive name.

*T* may be either a type or in case of type expansion a value.

Arrays are represented by `T[L]` where *T* is the type and *L*
the element count. *L* can have the same values as *S*.
If *L* is \* the count fits exactly *S*.

*S* may be a number, name, \* or ?.
- If name, depends on the value assigned to the name.
- If \*, the size of *T* is variable and requires reading it.
- If ?, its size depends on the value of the previous *u64*.

These three snippets describe the same thing:

```rs
[*] : u64      - Size
[*] : u8[Size] - Data
```

```rs
[*] : u64   - Size
[*] : u8[?] - Data
```

```rs
[*] : u64   - Size
[?] : u8[?] - Data
```

## Base Types

| Data Type |   Encoding    |
| :-------: | :-----------: |
|    f64    |    IEEE754    |
|    u64    |    ULEB128    |
|    i64    |    SLEB128    |
|    u32    | Little Endian |
|    u16    | Little Endian |
|    u8     |               |

*f64* is a [double precision floating point](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)
number and its bytes are stored in [little endian](https://en.wikipedia.org/wiki/Endianness) order.

64 bit signed and unsigned integers are stored using the [LEB128](https://en.wikipedia.org/wiki/LEB128) encoding.

Other integers use [little endian](https://en.wikipedia.org/wiki/Endianness) as their byte order.

## Neutron File

```rs
[4] : "\0NTR" - Signature
[4] : u32     - Format Version
[*] : Module  - Module
```

*Format Version* is the version of this spec.

- 0 = v0
- 1 = v1
- ...

## List\<T>

`List<T>` is a generic list containing elements of type `T`.

```rs
[*] : u64     - Size
[*] : T[Size] - Elements
```

*T* is a type within this spec.

## String

`String` is a list of characters.

```rs
[*] : u64      - Size
[*] : u8[Size] - Text
```

*Text* is not null-terminated.

*Text* may be UTF8-encoded, though a character within the Pulsar VM
corresponds to a single byte.

## SourcePosition

`SourcePosition` represents a position within a Pulsar source file.

```rs
[*] : u64 - Line
[*] : u64 - Char
[*] : u64 - Index
[*] : u64 - Char Span
```

*Line* indicates a 0-indexed line of a text file.

*Char* is the index of a character within *Line*.

*Index* is the global index of a character (i.e. let `s` be a
`String` containing a text file, `s[Index]` is the *Char* at *Line*).

*Char Span* is how many characters to consider starting from *Char*
at line *Line*.

## Token

`Token` is data generated by the Pulsar Lexer.

```rs
[2] : u16            - Token Type
[*] : SourcePosition - Source Position
```

## FunctionDebugSymbol

`FunctionDebugSymbol` contains information about where a
`FunctionDefinition` was generated from a Pulsar source file.

```rs
[*] : Token - Token
[*] : u64   - Source Index
```

*Source Index* is an index within `Module#SourceDebugSymbols`.

## BlockDebugSymbol

`BlockDebugSymbol` contains information about where a
sequence of `Instruction`s starts in a Pulsar source file.

```rs
[*] : Token - Token
[*] : u64   - Start Index
```

*Start Index* is an index within `FunctionDefinition#Code`.

## Instruction

`Instruction` is an instruction within the Pulsar VM.

```rs
[1] : u8  - Instruction Code
[*] : i64 - Arg0
```

A list of all *Instruction Code*s will be available in the future.

## FunctionDefinition

`FunctionDefinition` represents a Pulsar function.

```rs
[*] : String            - Name
[*] : u64               - Arity
[*] : u64               - Returns
[*] : u64               - Locals Count
[*] : u64               - Code Size
[?] : List<Instruction> - Code
[*] : u64               - Debug Size
[*] : u8[Debug Size]    - Debug Data
```

*Code Size* is the size in bytes of *Code*.

Where *Debug Data* is:

```rs
[*] : FunctionDebugSymbol    - Debug Symbol
[*] : List<BlockDebugSymbol> - Code Debug Symbols
```

*Debug Data* is not required for the correct execution of a function.
And may be either discarded while reading the Neutron file or
not serialized when writing one (in which case *Debug Size* is 0).

## Value

`Value` is a value within the Pulsar VM.

```rs
[1] : u8            - Value Type
[*] : u64           - Data Size
[*] : u8[Data Size] - Data
```

Where the size of *Data* depends on *Value Type*.

## Value/Void

```rs
[1] : 0x00  - Value Type
[1] : 0     - Data Size
[*] : u8[0] - Data
```

## Value/Integer

```rs
[1] : 0x01 - Value Type
[*] : u64  - Data Size
[?] : i64  - Integer
```

## Value/Double

```rs
[1] : 0x02 - Value Type
[1] : 8    - Data Size
[8] : f64  - Double
```

## Value/FunctionReference

```rs
[1] : 0x03 - Value Type
[*] : u64  - Data Size
[?] : i64  - Function Index
```

## Value/NativeFunctionReference

```rs
[1] : 0x04 - Value Type
[*] : u64  - Data Size
[?] : i64  - Native Function Index
```

## Value/List

```rs
[1] : 0x05        - Value Type
[*] : u64         - Data Size
[?] : List<Value> - Value List
```

## Value/String

```rs
[1] : 0x06   - Value Type
[*] : u64    - Data Size
[?] : String - String
```

## Value/CustomData

The support of this kind of type is completely optional.
And depends on the implementation of the Reader or Writer.

```rs
[1] : 0xFF                 - Value Type
[*] : u64                  - Data Size
[*] : String               - Type
[*] : u64                  - Custom Data Size
[*] : u8[Custom Data Size] - Custom Data
```

*Data Size* is the size of all the data that follows the field.

What's in *Custom Data* depends on *Type* which also depends on the Pulsar runtime used.
Different runtimes may define the same type with different structures.

*Type* should also contain the name of the runtime:

i.e. `Type = "Pulsar-Tools/Lexer"`

## GlobalDebugSymbol

`GlobalDebugSymbol` contains information about where a
`GlobalDefinition` was generated from a Pulsar source file.

```rs
[*] : Token - Token
[*] : u64   - Source Index
```

*Source Index* is an index within `Module#SourceDebugSymbols`.

## GlobalDefinition

`GlobalDefinition` represents a Pulsar global variable.

```rs
[*] : String         - Name
[1] : u8             - Flags
[*] : Value          - Initial Value
[*] : u64            - Debug Size
[*] : u8[Debug Size] - Debug Data
```

Where *Debug Data* is:

```rs
[*] : GlobalDebugSymbol - Debug Symbol
```

*Debug Data* is not required for the correct representation of a
global. And may be either discarded while reading the Neutron file
or not serialized when writing one (in which case *Debug Size* is 0).

Where the bits of *Flags* define different properties:

```rs
[0] - Is Constant
```

Bits are indexed from the least to the most significant one.

The ones not specified do not currently have a meaning.
So they should be set to 0 in case of backwards compatibility.

## SourceDebugSymbol

`SourceDebugSymbol` represents the contents of a Pulsar source file.

```rs
[*] : String - Path
[*] : String - Source
```

## Module

```rs
[*] : u64      - Size
[?] : Chunk[*] - Chunks
```

*Size* is the size in bytes of the *Module*.
If 0, *Chunks* must be read until a *Chunk/EndOfModule* is found.
Otherwise, the Reader must expect *Size* bytes which will contain
any (fitting) amount of *Chunk*s with the last one being a
*Chunk/EndOfModule*.

Any data after a *Chunk/EndOfModule* is not part of the Neutron
format and may be ignored.

Multiple *Chunk*s of the same type may be present.
And they are merged while reading.

*Chunk*s must be stored so that references are not broken.
Which means that, when reading multiple *Chunk*s of the same
type, their data must be kept in the same order as found.

A *Module* with not enough data to be ran will error at Runtime.
Basically, no *Chunk* is strictly required (except for
*Chunk/EndOfModule*). An empty Module is valid.

## Chunk

```rs
[1] : u8       - Chunk Type
[*] : u64      - Size
[*] : u8[Size] - Data
```

A *Chunk Type* greater or equal to `0x80` is completely optional
for the correct execution of the file. If an unknown one with a
smaller value is found, the Reader should error.

*Data* is to be interpreted based on *Chunk Type*.

### Chunk/EndOfModule

```rs
[1] : 0x00 - Chunk Type
[1] : 0    - Size
```

### Chunk/Functions

```rs
[1] : 0x01                     - Chunk Type
[*] : u64                      - Size
[?] : List<FunctionDefinition> - Functions
```

### Chunk/NativeBindings

```rs
[1] : 0x02                     - Chunk Type
[*] : u64                      - Size
[?] : List<FunctionDefinition> - Native Bindings
```

### Chunk/Globals

```rs
[1] : 0x03                   - Chunk Type
[*] : u64                    - Size
[?] : List<GlobalDefinition> - Globals
```

### Chunk/Constants

```rs
[1] : 0x04        - Chunk Type
[*] : u64         - Size
[?] : List<Value> - Constants
```

### Chunk/SourceDebugSymbols

```rs
[1] : 0x80                    - Chunk Type
[*] : u64                     - Size
[?] : List<SourceDebugSymbol> - SourceDebugSymbols
```
